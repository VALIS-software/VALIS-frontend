import { Device, GPUProgram, GPUBuffer, GPUVertexState } from '../rendering/Device';

/*

Old Device Method

*/
// query capabilties
	// handles object creation and deletion, with simplifying management layer
	// texture slot management
	// state-machine free

	// get programCount() {  }
	// get vertexStateCount() { return this.vertexStateMap.size }

	// protected vertexShaders = new Map<string, WebGLShader>();
	// protected fragmentShaders = new Map<string, WebGLShader>();

	// programs are referenced by an id (their index into the 'programs' array) to enable faster state batching
	// protected programs = new Array<WebGLProgram>();
	// protected programShaderMap = new Map<string, number>();

	// protected vertexStateMap = new Map<string, number>();

	

	// @! maybe this is an antipattern
	getSharedVertexStateHandle(vertexState: VertexState) {
		let key = this.vertexStateKey(vertexState);
		let vertexStateHandle = this.vertexStateMap.get(key);
		if (vertexStateHandle != null) {
			return vertexStateHandle;
		}

		// handle doesn't already exist, create one
		const gl = this.gl;
		const vaoExt = this.vaoExt;
		let vao = this.vaoExt.createVertexArrayOES();
		vaoExt.bindVertexArrayOES(vao);
		{
			if (vertexState.index != null) {
				// set index
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexState.index.uid);
			}

			// set attributes
			for (let i = 0; i < vertexState.attributes.length; i++) {
				let attribute = vertexState.attributes[i];
				if (attribute instanceof Float32Array) {
					gl.vertexAttrib4fv(i, attribute); // @! review this works with < 4
				} else {
					gl.bindBuffer(gl.ARRAY_BUFFER, attribute.buffer.uid);
					gl.enableVertexAttribArray(i);
					gl.vertexAttribPointer(gl.ARRAY_BUFFER, attribute.elementsPerVertex, attribute.dataType, !!attribute.normalize, attribute.offset, attribute.stride);
				}
			}
		}
		vaoExt.bindVertexArrayOES(null);

		this.vertexStateMap.set(key, n);
	}

	protected vertexStateKey(vertexState: VertexState) {
		let key = (vertexState.index == null ? '*' : this.getBufferHandle(vertexState.index).id + '|');
		for (let i = 0; i < vertexState.attributes.length; i++) {
			let attribute = vertexState.attributes[i];
			if (attribute instanceof Float32Array) {
				key += `[${attribute.join(',')}`;
			} else {
				key += `${
					this.getBufferHandle(attribute.buffer).id
				},${
					attribute.dataType
				},${
					attribute.elementsPerVertex
				},${
					attribute.offset
			 	},${
					attribute.stride
				},${
					attribute.normalize ? 1 : 0
			 	}`;
			}
			key += ';'
		}
		return key;
	}

	protected getBufferHandle(buffer: VertexArrayBuffer) {
		throw 'todo';
	}




enum BlendMode {
	None = 0,
	PremultipliedAlpha = 1,
}

class Renderer {

	protected gl: WebGLRenderingContext;

	constructor(protected device: Device) {
		this.gl = (device as any).gl;
		this.initializeGLState();
	}

	protected initializeGLState() {
		const gl = this.gl;
	}

	private _opaque = new Array<Renderable<any>>();
	private _transparent = new Array<Renderable<any>>();
	render(pass: RenderPass) {
		// let renderContext = f(device)
		const gl = this.gl;

		// render-state = transparent, programId, vertexStateId, blendMode, user
		// when transparent, z sort should override everything, but same-z should still sort by state
		// when opaque, z sort should come after user sort and depth within tree 
		//		programId, vertexStateId, blendMode, user-state, z, tree-depth

		// to avoid re-allocating a new array each frame, we reuse display list arrays from the previous frame and trim any excess
		let opaqueIndex = 0;
		let transparentIndex = 0;
		let opaque = this._opaque;
		let transparent = this._transparent;

		// iterate nodes, build optimized list for rendering
		for (let node of pass.root) {
			if (node instanceof Renderable) {
				if (!node.render) continue;

				let nodeInternal = node as any as RenderableInternal;

				// render any dependent render passes
				for (let subpass of node.dependentRenderPasses) {
					this.render(subpass);
				}

				if (nodeInternal.gpuResourcesNeedUpdate) {
					node.updateGPUResources(this.device);
				}

				internal._renderStateKey = this.encodeRenderState(
					internal.gpuProgram.id,
					internal.gpuVertexState.id,
					node.blendMode
				);
				
				// transparent nodes are rendered from furthest to nearest
				if (node.transparent) {
					transparent[transparentIndex++] = node;
				} else {
					opaque[opaqueIndex++] = node;
				}
			}
		}

		// trim any excess elements from the last frame
		if (opaqueIndex < opaque.length) {
			opaque.length = opaqueIndex;
		}
		if (transparentIndex < transparent.length) {
			transparent.length = transparentIndex;
		}

		// sort opaque objects for rendering
		opaque.sort((a, b) => {
			let ai = a as any as RenderableInternal;
			let bi = b as any as RenderableInternal;
			return ai._renderStateKey - bi._renderStateKey;
		});

		// begin rendering
		gl.bindFramebuffer(gl.FRAMEBUFFER, pass.target);

		let clearFlags = 0;
		if (pass.clearOptions.clearColor != null) {
			clearFlags |= gl.COLOR_BUFFER_BIT;
			gl.clearColor(pass.clearOptions.clearColor[0], pass.clearOptions.clearColor[1], pass.clearOptions.clearColor[2], pass.clearOptions.clearColor[3]);
		}

		if (pass.clearOptions.clearDepth != null) {
			clearFlags |= gl.DEPTH_BUFFER_BIT;
			gl.clearDepth(pass.clearOptions.clearDepth);
		}

		if (pass.clearOptions.clearStencil != null) {
			clearFlags |= gl.STENCIL_BUFFER_BIT;
			gl.clearStencil(pass.clearOptions.clearStencil);
		}

		gl.clear(clearFlags);

		// draw opaque objects
		let lastProgramId = -1;
		let lastVertexId = -1;
		let lastBlendMode = -1;
		for (let i = 0; i < opaque.length; i++) {
			let renderable = opaque[i];
			let internal = renderable as any as RenderableInternal;

			let programId = (internal._renderStateKey & this.stateSMask) >>> this.stateSOffset;
			let vertexId = (internal._renderStateKey & this.stateBMask) >>> this.stateBOffset;
			let blendMode = (internal._renderStateKey & this.stateMMask) >>> this.stateMOffset;

			if (programId !== lastProgramId) {
				gl.useProgram(this.device.getProgram(programId));
				lastProgramId = programId;
			}

			if (vertexId !== lastVertexId) {
				lastVertexId = vertexId;
			}

			if (blendMode !== lastBlendMode) {

				if (blendMode === 0) {
					gl.disable(gl.BLEND);
				} else {
					if (lastBlendMode <= 0) {
						gl.enable(gl.BLEND);
					}

					switch (blendMode) {
						case BlendMode.PremultipliedAlpha:
							gl.blendEquation(gl.FUNC_ADD);
							gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
							break;
					}
				}

				lastBlendMode = blendMode;
			}

			// renderable.draw(shaderContext / drawContext?)
		}
	}

	// In JavaScript we only get bitwise operations on 32-bit integers
	// 00000000 00000000 00000000 00000000
	// ssssssss bbbbbbbb bbbbbbbb bbbbmmmm
	protected readonly stateSOffset = 24;
	protected readonly stateSMask = 0xFF000000;
	protected readonly stateBOffset = 4;
	protected readonly stateBMask = 0x00FFFFF0;
	protected readonly stateMOffset = 0;
	protected readonly stateMMask = 0x0000000F;

	readonly MAX_SHADERS = this.stateSMask >>> this.stateSOffset;
	readonly MAX_BUFFERS = this.stateBMask >>> this.stateBOffset;
	readonly MAX_BLEND_MODES = this.stateMMask >>> this.stateMOffset;

	protected encodeRenderState(programId: number, vertexStateId: number, blendMode: number): number {
		return (programId << this.stateSOffset) |
			(vertexStateId << this.stateBOffset) |
			(blendMode << this.stateMOffset);
	}

	protected decodeRenderState(bits: number) {
		return {
			programId: (bits & this.stateSMask) >>> this.stateSOffset,
			vertexStateId: (bits & this.stateBMask) >>> this.stateBOffset,
			blendMode: (bits & this.stateMMask) >>> this.stateMOffset
		}
	}

}


// GPU Objects

class RenderPass {

	constructor(
		public target: any,
		public root: Node<any>,
		public clearOptions: {
			clearColor?: Array<number>,
			clearDepth?: number,
			clearStencil?: number,
		}
	) {
		if (target != null) {
			throw 'Framebuffer target not yet supported';
		}
	}

}

import { EventEmitter } from 'events';

type RenderableInternal = {
	worldTransformNeedsUpdate: boolean;
	gpuResourcesNeedUpdate: boolean;
	_renderStateKey: number;
	_programId: number;
	_vertexStateId: number;
}

class Renderable<T> extends Node<T> {

	// set to false to disable rendering of this object
	render = true;
	// influences render order if transparent and sets precedence between otherwise equal state objects
	z: number;
	// when true, object is rendered in the transparency pass, this has a performance cost because z ordering has to take precedence over state-change-minimization ordering
	transparent = false;

	dependentRenderPasses = new Array<RenderPass>();
	blendMode = BlendMode.None;

	protected worldTransformNeedsUpdate = true;

	// @:device-local
	protected gpuProgram: GPUProgram = null;
	protected gpuVertexState: GPUVertexState = null;
	protected gpuResourcesNeedUpdate = true;

	// non-owned fields
	private _renderStateKey: number = 0 | 0;

	constructor() {
		super();
	}

	add(child: Renderable<T>) {
		super.add(child);
		child.worldTransformNeedsUpdate = true;
	}

	updateGPUResources(device: Device) {}

	// protected updateVertexState(device: Device): void {}
	// protected draw()

}

type Object2DInternal = RenderableInternal & {
	handlesPointerEvents: boolean;
	localTransformMat4: Float32Array;
	eventEmitter: EventEmitter;
	_worldTransformMat4: Float32Array;
}

/*
	Implements 2D transforms and user interaction event handling
*/
class Object2D extends Renderable<Object2D> {

	bounds = {
		l: 0, r: 0,
		t: 0, b: 0
	}

	// position
	set x(v: number) { this.localTransformMat4[12] = v; this.worldTransformNeedsUpdate = true; }
	get x() { return this.localTransformMat4[12]; }
	set y(v: number) { this.localTransformMat4[13] = v; this.worldTransformNeedsUpdate = true; }
	get y() { return this.localTransformMat4[13]; }
	set z(v: number) { this.localTransformMat4[14] = v; this.worldTransformNeedsUpdate = true; }
	get z() { return this.localTransformMat4[14]; }

	// scale
	set sx(v: number) { this.localTransformMat4[0] = v; this.worldTransformNeedsUpdate = true; }
	get sx() { return this.localTransformMat4[0]; }
	set sy(v: number) { this.localTransformMat4[5] = v; this.worldTransformNeedsUpdate = true; }
	get sy() { return this.localTransformMat4[5]; }

	protected handlesPointerEvents: Boolean = false;
	protected localTransformMat4 = new Float32Array([
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	]);
	protected worldTransformMat4 = new Float32Array(16);
	protected eventEmitter = new EventEmitter();
	protected cursor = 'pointer';

	constructor() {
		super();
		// @! if this is a subclass of Object2D, set render to true, otherwise false
	}

	onPointerDown(listener: (event: any) => void) {
		this.handlesPointerEvents = true;
		this.eventEmitter.on('pointerdown', listener);
	}

	onPointerUp(listener: (event: any) => void) {
		this.handlesPointerEvents = true;
		this.eventEmitter.on('pointerup', listener);
	}

	removePointerDown(listener: (event: any) => void) {
		this.eventEmitter.removeListener('pointerdown', listener);
		this.handlesPointerEvents = this.eventEmitter.eventNames().length > 0;
	}

	removePointerUp(listener: (event: any) => void) {
		this.eventEmitter.removeListener('pointerup', listener);
		this.handlesPointerEvents = this.eventEmitter.eventNames().length > 0;
	}

	emitPointerDown(detail: any) {
		this.eventEmitter.emit('pointerdown', detail);
	}

	removeAllListeners() {
		this.eventEmitter.removeAllListeners();
		this.handlesPointerEvents = false;
	}

}

class Rect extends Object2D {

	static vertexCode = `
		attribute vec3 position;

		precision mediump float;

		void main() {
			gl_Position = vec4(position, 1.0);
		}
	`;

	static fragmentCode = `
		#version 100

		precision mediump float;

		void main() {
			gl_FragColor = vec4(1., 0., 0., 1.);
		}
	`;

	static unitQuadIndex = new IndexBuffer(new Uint8Array([
		0, 1, 2,
		0, 1, 3
	]));

	static unitQuadBuffer = new VertexArrayBuffer(new Float32Array([
		-1.0, -1.0,
		 1.0,  1.0,
		-1.0,  1.0,
		 1.0, -1.0,
	]));

	static unitQuadVertexState = null;

	static initialize(device: Device) {
		let indexBuffer = device.createBuffer(Rect.unitQuadIndex);
		let positionBuffer = device.createBuffer(Rect.unitQuadBuffer);
		// @! upload buffers
		Rect.quadVertexStateHandle = device.createVertexState({
			index: indexBuffer,
				attributes: [
					{ // position
						buffer: Rect.unitQuadIndex,
						elementsPerVertex: 2,
						dataType: VertexAttributeDataType.FLOAT,
						offset: 0,
						stride: 0
					}
				]
		}));
		
		Rect.gpuProgram = device.createProgram(Rect.vertexCode, Rect.fragmentCode, ['position']);
	}

	constructor() {
		super();
	}

	updateGPUResources(device: Device) {
		if (Rect.unitQuadVertexState == null) {
			Rect.initialize(device);
		}

		this.gpuVertexState = Rect.unitQuadVertexState;	
	}

	protected updateProgram(device: Device) {
		/*
		// we dont want to create a new program for each rect
		// we want to be able to control attributes
		// usually a renderable only has one program over its lifetime

		device.getProgram()

		let programId = device.createProgram(Rect.vertexCode, Rect.fragmentCode, {
			position: 0,
		});
		*/
	}

	protected updateVertexState(device: Device) {
		// free buffers, allocate new ones
		// return a vertex state object?
		// vertex state = vertex array object 
		// 		Buffer +
		/*
		let gl: WebGLRenderingContext;
		let vaoExt: OES_vertex_array_object;

		// created by some common buffer library
		let unitQuad = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, unitQuad);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			-1.0, -1.0,
			 1.0,  1.0,
			-1.0,  1.0,
			 1.0, -1.0,
		]), gl.STATIC_DRAW);
		gl.bindBuffer(gl.ARRAY_BUFFER, null);

		let unitQuadIndex = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, unitQuadIndex);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array([
			0, 1, 2,
			0, 1, 3
		]), gl.STATIC_DRAW);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
		*/

		/*
			VertexAttribute(buffer, elementsPerVertex, dataType, offset, stride, normalize)
		*/


		// ! problem: we normally don't want a new VAO for each instance, same with shaders
		// rect = always the same for all instances
		// text = always different for all instances

		// build vertex state object
		/*
			index?: unitQuadIndex,
			attributes: [
				@position vertexArray {buffer: unitQuad, elementsPerVertex: 2, dataType: gl.Float, offset: 0, stride: 0, normalize?: false}
				@uv       vertexArray {buffer: unitQuadUv, elementsPerVertex: 2, dataType: gl.Float, offset: 0, stride: 0, normalize?: false}
				@color    constant    {value: <float32array> }
			]
		*/
		/*
		let vao = vaoExt.createVertexArrayOES();
		vaoExt.bindVertexArrayOES(vao);
		{
			// set index
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, unitQuadIndex);
			// set attributes
			gl.bindBuffer(gl.ARRAY_BUFFER, unitQuad);
			gl.enableVertexAttribArray(0);
			gl.vertexAttribPointer(gl.ARRAY_BUFFER, 2, gl.FLOAT, false, 0, 0);
		}
		vaoExt.bindVertexArrayOES(null);
		*/

		// approach 1, automatic caching - we return the vertex state object, create a signature and internally alias it
		// 	problem: how do we delete unwanted vertex states (as in the case of text buffers)
		//  we expose some of the caching mechanism:
		//		device.getVertexStateHandle(vertexStateDescriptor);
		//  then
		//		device.deleteVertexState(vertexStateHandle)
		//  so we can't explicitly create vertex state but we can delete it
		//  this presents a new problem: how do we know when we can delete the vao?
		//  > ? when we assume it's unique
		//  what if we enable explicit creation of vao, in this case it's not allowed to be aliased

		//  problem: buffers are not deleted until the object is rendered again
		//  for example, if we have a large text buffer and we decide to remove it from the scene graph, its memory stays allocated
		//  the issue is that we don't have access to a device handle in order to free data
		//  > we could store the device handle associated with a given buffer and vertex state handle
		/*
			type GPUObjectHandle = {
				device: device,
			}
		*/

		// problem: should buffers also be referenced by CPU-side descriptors? It makes buffer updates tricky (same for textures)
		// > Yes as long as buffer updates only possible with device access
		// let unitQuad = new GPUBuffer(data)
			// .data is not accessible
		// device.setBufferData(buffer: GPUBuffer, newData)
			// creates if doesnt exist
			// changes GPU data
			// ? changes CPU data (probably not)
		// how do you push the buffer onto the GPU?
			// device.synchronizeBuffer();?
			// why not device.getBufferHandle()?

		//  what about for buffers?
		//		device.createBuffer(length/?data): bufferHandle;
		//		device.updateBuffer(handle, ...)
		//		device.deleteBuffer(descriptor | handle)
		//		bufferHandle could be WebGLBuffer in this case (but how do we then map descriptors to buffers?)

		/*
			for text:
				if (oldHandle) device.deleteVertexState(oldHandle)
				device.createVertexState()

		*/

		/* 
		vertexState
			- mulitple buffers
				- bufferData(target:BufferTarget, data:BufferDataSource, usage:BufferUsage)
				- bufferSubData(target:BufferTarget, offset:GLintptr, data:BufferDataSource)
			- enableVertexAttribArray(index:GLuint)
			- disableVertexAttribArray(index:GLuint)
			- vertexAttrib*(index:GLuint, ...)
			- vertexAttribPointer(index:GLuint, size:GLint, type:DataType, normalized:Bool, stride:GLsizei, offset:GLintptr)
		*/
	}

}

class Text extends Object2D {

	vertexState: VertexState = null;
	
	// protected _lastTextBuffer: VertexArrayBuffer;
	constructor(text: string) {
		super();
		this.text = text;
	}

	set text(str: string) {
		if (this.lastBufferHandle != null) {
			this.lastBufferHandle.delete();
		}

		/*
		device.deleteBuffer(oldBufferHandle);

		let vertexBuffer = ...;
		let vertexBufferHandle = this.device.createBuffer(vertexBuffer);

		this.device.deleteVertexState(this.vertexStateHandle);
		this.vertexStateObject = this.device.getVertexStateObject({
			index: null,
			attributes: [
				{buffer: vertexBufferHandle}
			]
		});
		*/

		// if (this.vertexStateHandle != null) {
			// this.vertexStateHandle.free();
			// @! how to free buffers?
			// this.bufferHandle.free();
		// }
		// delete previous buffer
		// if (_lastTextBuffer != null) {
			// _lastTextBuffer.free()
		// }

		// let vertexArray = generateVertexData()
		// let vertexBuffer = new VertexArrayBuffer(vertexData);
		// this.vertexState.attributes[0].buffer = vertexBuffer;
		// this.vertexState.attributes[1].buffer = vertexBuffer;
		// this.vertexStateNeedsUpdate = true;
		// this._lastTextBuffer = vertexBuffer;

		this.vertexStateNeedsUpdate = true;
	}

	updateVertexState(device: Device, oldVertexStateHandle)/*: new handle*/ {
		// @! delete old vertexStateObject
		// @! initialize new buffer
		oldVertexStateHandle.delete();
		return device.getVertexStateHandle({
			indexBufferHandle: 0,
			attributes: [
				{bufferHandle: 0}
			]
		});
	}

}